import { readFileSync, writeFileSync, readdirSync, statSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT_DIR = join(__dirname, '..');
const SVG_DIR = join(ROOT_DIR, 'assets');
const SRC_DIR = join(ROOT_DIR, 'src');

// Auto-generated file header
const AUTO_GENERATED_HEADER = `/**
 * THIS FILE IS AUTO-GENERATED. DO NOT EDIT MANUALLY.
 * Generated by: pnpm generate
 * Source: packages/design/svgs/scripts/generate.ts
 */
`;

// Convert file name to PascalCase React component name
function toPascalCase(str: string): string {
  return str
    .replace(/\.svg$/, '')
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('');
}

// Get all SVG files from a directory
function getSvgFiles(dir: string, prefix = ''): { name: string; path: string; content: string }[] {
  const files: { name: string; path: string; content: string }[] = [];

  if (!existsSync(dir)) {
    return files;
  }

  const entries = readdirSync(dir);

  for (const entry of entries) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      // Recursively get files from subdirectories with prefix
      const subFiles = getSvgFiles(fullPath, entry);
      files.push(...subFiles);
    } else if (entry.endsWith('.svg')) {
      const name = prefix ? `${prefix}-${entry.replace('.svg', '')}` : entry.replace('.svg', '');
      files.push({
        name,
        path: fullPath,
        content: readFileSync(fullPath, 'utf-8'),
      });
    }
  }

  return files;
}

// Extract SVG attributes and content
function parseSvg(content: string): {
  viewBox: string;
  width: string;
  height: string;
  fill: string;
  innerContent: string;
} {
  const viewBoxMatch = content.match(/viewBox="([^"]+)"/);
  const widthMatch = content.match(/width="([^"]+)"/);
  const heightMatch = content.match(/height="([^"]+)"/);
  const fillMatch = content.match(/<svg[^>]*fill="([^"]+)"/);

  // Extract inner content (between <svg> and </svg>)
  const innerMatch = content.match(/<svg[^>]*>([\s\S]*)<\/svg>/);
  const innerContent = innerMatch ? innerMatch[1].trim() : '';

  return {
    viewBox: viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24',
    width: widthMatch ? widthMatch[1] : '24',
    height: heightMatch ? heightMatch[1] : '24',
    fill: fillMatch ? fillMatch[1] : 'none',
    innerContent,
  };
}

// Generate sprite SVG file with all icons as symbols
function generateSpriteSvg(files: { name: string; content: string }[]): string {
  const symbols = files.map((file) => {
    const { viewBox, innerContent, fill } = parseSvg(file.content);
    // Use fill="currentColor" for icons to allow CSS color inheritance
    const symbolFill = fill === 'none' ? 'currentColor' : fill;

    return `  <symbol id="${file.name}" viewBox="${viewBox}" fill="${symbolFill}">
${innerContent.split('\n').map(line => `    ${line}`).join('\n')}
  </symbol>`;
  }).join('\n\n');

  return `<!-- THIS FILE IS AUTO-GENERATED. DO NOT EDIT MANUALLY. -->
<!-- Generated by: pnpm generate -->
<!-- Source: packages/design/svgs/scripts/generate.ts -->
<svg xmlns="http://www.w3.org/2000/svg" style="position:absolute;width:0;height:0;overflow:hidden" aria-hidden="true">
${symbols}
</svg>
`;
}

// Generate React component for an SVG
function generateReactComponent(
  name: string,
  content: string,
): string {
  const componentName = toPascalCase(name);
  const { viewBox, innerContent, fill } = parseSvg(content);

  // Clean up inner content - fix JSX attributes
  const jsxContent = innerContent
    .replace(/clip-path=/g, 'clipPath=')
    .replace(/fill-rule=/g, 'fillRule=')
    .replace(/clip-rule=/g, 'clipRule=')
    .replace(/stroke-width=/g, 'strokeWidth=')
    .replace(/stroke-linecap=/g, 'strokeLinecap=')
    .replace(/stroke-linejoin=/g, 'strokeLinejoin=')
    .replace(/stroke-miterlimit=/g, 'strokeMiterlimit=')
    .replace(/fill-opacity=/g, 'fillOpacity=')
    .replace(/stroke-opacity=/g, 'strokeOpacity=')
    .replace(/stop-color=/g, 'stopColor=')
    .replace(/stop-opacity=/g, 'stopOpacity=')
    .replace(/xlink:href=/g, 'xlinkHref=')
    .replace(/xml:space=/g, 'xmlSpace=')
    .replace(/xmlns:xlink=/g, 'xmlnsXlink=');

  // Determine default fill based on SVG content
  const defaultFill = fill === 'none' ? 'currentColor' : fill;

  return `${AUTO_GENERATED_HEADER}
import { forwardRef } from 'react';
import type { SVGProps } from 'react';

export interface ${componentName}Props extends SVGProps<SVGSVGElement> {
  size?: string | number;
  title?: string;
}

export const ${componentName} = forwardRef<SVGSVGElement, ${componentName}Props>(
  ({ size = 24, title, ...props }, ref) => (
    <svg
      ref={ref}
      width={size}
      height={size}
      viewBox="${viewBox}"
      fill="${defaultFill}"
      xmlns="http://www.w3.org/2000/svg"
      role={title ? 'img' : 'presentation'}
      aria-label={title}
      {...props}
    >
      {title && <title>{title}</title>}
      ${jsxContent}
    </svg>
  ),
);

${componentName}.displayName = '${componentName}';
export default ${componentName};
`;
}

// Generate index file for React components
function generateReactIndex(files: { name: string }[]): string {
  const exports = files
    .map((file) => {
      const componentName = toPascalCase(file.name);
      return `export { ${componentName}, type ${componentName}Props } from './${componentName}.js';`;
    })
    .join('\n');

  return `${AUTO_GENERATED_HEADER}
${exports}`;
}

// Generate names.ts file
function generateNamesFile(category: string, files: { name: string }[]): string {
  const names = files.map((file) => file.name);
  const constName = `${category.toUpperCase()}_NAMES`;
  const typeName = `${category.charAt(0).toUpperCase() + category.slice(1, -1)}Name`;

  return `${AUTO_GENERATED_HEADER}
export const ${constName} = [
${names.map((n) => `  '${n}',`).join('\n')}
] as const;

export type ${typeName} = (typeof ${constName})[number];
`;
}

// Generate simplified HTML exports (sprite-based approach)
function generateSpriteExports(category: string, spriteContent: string): string {
  const namesConstName = `${category.toUpperCase()}_NAMES`;
  const typeName = `${category.charAt(0).toUpperCase() + category.slice(1, -1)}Name`;
  const spritePathConst = `${category.toUpperCase()}_SPRITE_PATH`;
  const spriteContentConst = `${category.toUpperCase()}_SPRITE`;
  const spritePath = `sprite-${category}.svg`;
  const cssClass = category === 'icons' ? 'gi-icon' : category === 'logos' ? 'gi-logo' : 'gi-favicon';

  // Escape backticks and ${} in SVG content for template literal
  const escapedContent = spriteContent
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${');

  return `${AUTO_GENERATED_HEADER}
import type { ${typeName} } from './names.js';

export { ${namesConstName}, type ${typeName} } from './names.js';

/**
 * Path to the sprite SVG file containing all ${category}.
 */
export const ${spritePathConst} = '${spritePath}';

/**
 * Inline sprite SVG content. Inject this once into your HTML:
 *
 * @example
 * // React/Next.js
 * <div dangerouslySetInnerHTML={{ __html: ${spriteContentConst} }} />
 *
 * // Then use icons via:
 * <svg class="${cssClass}" width="24" height="24" aria-hidden="true" focusable="false">
 *   <use href="#icon-name"></use>
 * </svg>
 */
export const ${spriteContentConst} = \`${escapedContent}\`;

/**
 * Helper to generate the SVG use element markup for a ${category.slice(0, -1)}.
 *
 * @example
 * // Returns: <svg class="${cssClass}" width="24" height="24" aria-hidden="true" focusable="false"><use href="#check"></use></svg>
 * get${typeName.replace('Name', '')}Use('check', { size: 24 })
 */
export function get${typeName.replace('Name', '')}Use(
  name: ${typeName},
  options?: {
    size?: number | string;
    className?: string;
    ariaLabel?: string;
  }
): string {
  const { size = 24, className = '${cssClass}', ariaLabel } = options || {};

  const ariaAttrs = ariaLabel
    ? \`aria-label="\${ariaLabel}" role="img"\`
    : 'aria-hidden="true"';

  return \`<svg class="\${className}" width="\${size}" height="\${size}" \${ariaAttrs} focusable="false"><use href="#\${name}"></use></svg>\`;
}
`;
}

// Main generation function
function generate() {
  console.log('Generating SVG components, sprites, and exports...');

  const categories = ['icons', 'logos', 'favicons'];

  for (const category of categories) {
    const svgDir = join(SVG_DIR, category);
    const files = getSvgFiles(svgDir);

    if (files.length === 0) {
      console.log(`No SVG files found in ${category}`);
      continue;
    }

    console.log(`Processing ${files.length} ${category}...`);

    // Create React components directory
    const reactDir = join(SRC_DIR, 'react', category);
    mkdirSync(reactDir, { recursive: true });

    // Generate React components
    for (const file of files) {
      const componentName = toPascalCase(file.name);
      const componentContent = generateReactComponent(file.name, file.content);
      const componentPath = join(reactDir, `${componentName}.tsx`);
      writeFileSync(componentPath, componentContent);
    }

    // Generate React index
    const reactIndexContent = generateReactIndex(files);
    writeFileSync(join(reactDir, 'index.ts'), reactIndexContent);

    // Create HTML exports directory
    const htmlDir = join(SRC_DIR, category);
    mkdirSync(htmlDir, { recursive: true });

    // Generate names file
    const namesContent = generateNamesFile(category, files);
    writeFileSync(join(htmlDir, 'names.ts'), namesContent);

    // Generate sprite SVG
    const spriteContent = generateSpriteSvg(files);
    writeFileSync(join(htmlDir, `sprite-${category}.svg`), spriteContent);
    console.log(`  Generated sprite-${category}.svg with ${files.length} symbols`);

    // Generate simplified HTML exports (sprite-based)
    const htmlExportsContent = generateSpriteExports(category, spriteContent);
    writeFileSync(join(htmlDir, 'index.ts'), htmlExportsContent);
  }

  // Generate main React index
  const reactMainIndex = `${AUTO_GENERATED_HEADER}
export * from './icons/index.js';
export * from './logos/index.js';
export * from './favicons/index.js';
`;
  writeFileSync(join(SRC_DIR, 'react', 'index.ts'), reactMainIndex);

  console.log('Generation complete!');
}

generate();
